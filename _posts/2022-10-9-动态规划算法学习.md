# 标有数值的矩形迷宫中使用动态规划学习笔记

****

- **在标有数值的矩形迷宫dp问题中不能按照题中所给条件进行顺序遍历，因可能会得不到最优解，应当从终点开始反向遍历，此时dp数组初始化应初始化为终点位置的值，转移方程视题中情况而定**

题目：

```
正处在某一特定时期之中的李大水牛由于消化系统比较发达，最近一直处在饥饿的状态中。某日上课，正当他饿得头昏眼花之时，眼前突然闪现出了一个 n * m(n,m <= 200) 的矩型的巨型大餐桌，而自己正处在这个大餐桌的一侧的中点下边。餐桌被划分为了 n * m 个小方格，每一个方格中都有一个圆形的巨型大餐盘，上面盛满了令李大水牛朝思暮想的食物。李大水牛已将餐桌上所有的食物按其所能提供的能量打了分（有些是负的，因为吃了要拉肚子），他决定从自己所处的位置吃到餐桌的另一侧，但他吃东西有一个习惯——只吃自己前方或左前方或右前方的盘中的食物。

由于李大水牛已饿得不想动脑了，而他又想获得最大的能量，因此，他将这个问题交给了你。

每组数据的出发点都是最后一行的中间位置的下方！

输入格式：
第一行为m n（n为奇数），李大水牛一开始在最后一行的中间的下方

接下来为m * n的数字距阵.

共有m行,每行n个数字.数字间用空格隔开.代表该格子上的盘中的食物所能提供的能量.

数字全是整数.

输出格式：
一个数,为你所找出的最大能量值.
```

代码：
```c++
#include <iostream>
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

int m, n;
int enegy[205][205];
ll dp[205][205];

int main()
{
	cin >> m >> n;
	for(int i = 1; i <= m; i++) {
		for(int j = 1; j <= n; j++) {
			cin >> enegy[i][j];
		}	
	}
	for(int i = 1; i <= n; i++) {
		dp[1][i] = enegy[1][i];
	}
	for(int i = 2; i <= m + 1; i++) {
		for(int j = 1; j <= n; j++) {
			dp[i][j] = max(dp[i - 1][j],max(dp[i - 1][j - 1], dp[i - 1][j + 1])) + enegy[i][j];
		}
	}
	cout << dp[m + 1][n / 2 + 1];
	return 0;
}
```


[洛谷P1508Likecloud-吃、吃、吃](https://www.luogu.com.cn/problem/P1508)